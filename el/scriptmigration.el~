(defvar *v2-namespace* nil)
(defvar *v1-prefix* nil)
(defvar *class-conversion* nil)
(defvar *ask-for-new-name* t)

(defun v2-namespace ()
  (or *v2-namespace*
      (setq *v2-namespace*
	    (save-excursion
	      (goto-char (point-min))
	      (when (re-search-forward "^//\\s-*V2NAMESPACE:\\s-*\\([[:word:]]+\\)" nil t)
		(match-string-no-properties 1))))))

(defun v1-prefix ()
  (or *v1-prefix*
      (setq *v1-prefix*
	    (save-excursion
	      (goto-char (point-min))
	      (when (re-search-forward "^//\\s-*V1PREFIX:\\s-*\\([[:word:]]+\\)" nil t)
		(match-string-no-properties 1))))))

(defun class-conversion ()
  (or *class-conversion*
      (setq *class-conversion*
	    (let ((ht (make-hash-table :test 'equal)))
	      (save-excursion
		(goto-char (point-min))
		(while (re-search-forward "^//\\s-*CLASSCONV:\\s-*\\([[:word:]]+\\)\\s-*:\\s-*\\([[:word:]]+\\)" nil t)
		  (puthash (match-string-no-properties 1) (match-string-no-properties 2) ht))
		ht)))))			   	    
	 
(defconst *mig-method-header-regexp* "method\\s-*\\([[:word:]]+\\)\\s-+on\\s-+\\([[:word:]]+\\)\\s-*(\\([[:word:], ]*\\))\\s-*{\\s-*")
(defconst *mig-function-header-regexp* "function\\s-*\\([[:word:]]+\\)\\s-*(\\([[:word:], ]*\\))\\s-*{\\s-*")

(defun transform-script-to-v2 ()
  (interactive)
  (setq *v2-namespace* nil
	*v1-prefix* nil
	*class-conversion* nil)
  (let ((*ask-for-new-name* nil))
    (goto-char (point-min))    
    (while (goto-start-of-next-function (point-max))
      (transform-to-v2))))
		

(defun transform-to-v2 ()
  (interactive)
  (let* ((fb (function-boundaries))
	 (start (when fb (car fb)))
	 (end (when fb (cdr fb)))
	 (prefix (v1-prefix))
	 (class-conv (class-conversion))
	 )
    (when fb
      (goto-char start)
      (let ((function? (looking-at "function"))
	    (method?   (looking-at "method")))
	(when (or function? method?)
	  (when (re-search-forward (cond (method? *mig-method-header-regexp*) (function? *mig-function-header-regexp*)))
	    (let ((function-name (if *ask-for-new-name*
				     (read-string (format "V2 %s name: " (cond (method? "method") (function? "function"))) (replace-regexp-in-string (format "^%s" prefix) "" (match-string-no-properties 1)))
				   (replace-regexp-in-string (format "^%s" prefix) "" (match-string-no-properties 1))))
		  (class       (when method? (or (gethash (replace-regexp-in-string "\\s-" "" (match-string-no-properties 2)) class-conv)
						 (replace-regexp-in-string "\\s-" "" (match-string-no-properties 2)))))
		  (args        (replace-regexp-in-string "\\s-" "" (match-string-no-properties (cond (function? 2) (method? 3)))))
		  (namespace (v2-namespace)))
	    
	      (next-line)
	      (beginning-of-line)
	      (delete-region (point) end)
	      (insert (if (equal args "")
			  (format "  callV2(\"%s\", \"%s\", new vector(this));" namespace function-name)
			(format "  callV2(\"%s\", \"%s\", new vector(this,%s));" namespace function-name args)))
	      (newline)
	      (insert "}")
	      ;; erase the next line if it is already a checkV2
	      (forward-line)
	      (beginning-of-line)
	      (when (looking-at "checkV2")
		(delete-region (point) (line-end-position)))
	      ;; if the line is not empty, insert a new line
	      (unless (looking-at "^$")		
		(newline)
		(forward-line -1))

	      ;; if next line is not empty, insert a new line
	      (save-excursion
		(forward-line)
		(unless (looking-at "^$")
		  (newline)))		  
	      
	      (cond (method?		     
		     (insert (format "checkV2method(\"%s\", \"%s\", \"%s\");" namespace function-name class)))
		    (function?
		     (insert (format "checkV2function(\"%s\", \"%s\");" namespace function-name)))))))))))		     


;; *ojs-function-heading*

(defun find-duplicate-declarations ()
  (interactive)  
  (goto-char (point-min))
  (while (re-real-search-forward *ojs-function-or-method-regexp* nil t)
    (let ((function-name (match-string 1))
	  (class-name    (match-string 2))
	  duplicates)
      (save-excursion
	(let ((regexp (if class-name
			  (format "\\s-*method\\s+%s\\s-on\\s-+%s" function-name class-name)
			(format "\\s-*function\\s+%s" function-name)))
	      (found (point)))
	  (beginning-of-line)
	  (while (re-real-search-backward regexp nil t)
	    (push (line-number-at-pos) duplicates))
	  (goto-char found)
	  (end-of-line)
	  (while (re-real-search-forward regexp nil t)
	    (push (line-number-at-pos) duplicates))))
      (when duplicates
	(push (line-number-at-pos) duplicates)
	(setq dups (sort duplicates '<))
	(if class-name
	    (message "Method %s on %s is defined multiple times on lines : %s"
		     function-name class-name duplicates)
	  (message "Function %s is defined multiple times on lines : %s"
		   function-name duplicates))))))
	  
